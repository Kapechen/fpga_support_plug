"use strict";
const vscode = require("vscode");
const fs = require("fs");
const fspath = require("path");
const dirs = require("./dirs");
const files = require("./files");

/**
 * the class of HDL file process
 * 
 */
class processHDLFile {
    constructor(opeParam, watcher) {
        this.opeParam = opeParam;
        this.watcher  = watcher;
        this.resourcePath   = fspath.dirname(opeParam.rootPath) + "/resources";
        this.localLibPath   = fspath.dirname(opeParam.rootPath) + "/lib";
        this.fileScriptPath = `${this.resourcePath}/tool/library.tcl`;
        this.script_content = "";
        if (fs.existsSync(this.fileScriptPath)) {
            fs.unlinkSync(this.fileScriptPath);
        }
        // All are represented in the form of library paths and no workspace paths
        this.oldLibFileList = [];
        this.newLibFileList = [];
    }

    /**
     * Remove duplicate element form the array
     * @param {*} array the array need to be removed duplicate element
     * @returns 
     */
    removeDuplicates(array) {
        // let r = [];
        // for (let i = 0, l = array.length; i < l; i++) {
        //     for (let j = i + 1; j < l; j++)
        //         if (array[i] === array[j]) j = ++i;
        //     r.push(array[i]);
        // }
        // return r;
        //changed 2021/8/4 18:15 kapechen
        let h = {};
        let arr = [];
        for(let i=0;i<array.length;i++){
            if(!h[array[i]]){
                h[array[i]] = true;
                arr.push(array[i]);
            }
        }
        return arr;
    }

    /**
     * get all the lib files from Common, xilinx, intel, Customer
     * @returns all the lib files from property.json
     */
    getLibFiles() {
        let libFileList = [];
        if (this.opeParam.propertyPath != "") {
            // Gets the path to the user-defined library
            let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
            // Get the HDL file of the local library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Common")) {
                this.opeParam.currentHDLPath.push(`${this.localLibPath}/src_lib/Hardware`);
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Common.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Common[i];
                    getHDLFiles(`${this.localLibPath}/src_lib/Hardware/${element}`, libFileList);
                }
            } else {
                let index = this.opeParam.currentHDLPath.indexOf(`${this.localLibPath}/src_lib/Hardware`);
                if (index != -1) {
                    this.opeParam.currentHDLPath.splice(index, 1);
                }
            }
            // Get the HDL file of the local Xilinx library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Xilinx_lib")) {
                this.opeParam.currentHDLPath.push(`${this.localLibPath}/Xilinx_lib/src`);
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Xilinx_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Xilinx_lib[i];
                    getHDLFiles(`${this.localLibPath}/Xilinx_lib/src/${element}`, libFileList);
                }
            } else {
                let index = this.opeParam.currentHDLPath.indexOf(`${this.localLibPath}/Xilinx_lib/src`);
                if (index != -1) {
                    this.opeParam.currentHDLPath.splice(index, 1);
                }
            }
            // Get the HDL file of the local Intel library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Intel_lib")) {
                this.opeParam.currentHDLPath.push(`${this.localLibPath}/Intel_lib/src`);
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Intel_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Intel_lib[i];
                    getHDLFiles(`${this.localLibPath}/Intel_lib/src/${element}`, libFileList);
                }
            } else {
                let index = this.opeParam.currentHDLPath.indexOf(`${this.localLibPath}/Intel_lib/src`);
                if (index != -1) {
                    this.opeParam.currentHDLPath.splice(index, 1);
                }
            }
            // Get the HDL file of the user-defined library and place it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Customer")) {
                if (fs.existsSync(customerlocalLibPath)) {
                    this.opeParam.currentHDLPath.push(customerlocalLibPath);
                    for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Customer.length; i++) {
                        const element = this.opeParam.prjInfo.HardwareLIB.Customer[i];
                        getHDLFiles(`${customerlocalLibPath}/${element}`, libFileList);
                    }
                } else {
                    let index = this.opeParam.currentHDLPath.indexOf(customerlocalLibPath);
                    if (index != -1) {
                        this.opeParam.currentHDLPath.splice(index, 1);
                    }
                    vscode.window.showErrorMessage(`The PRJ.customer.Lib.repo.path ${PRJ.customer.Lib.repo.path} do not exist.`);
                }
            } else {
                let index = this.opeParam.currentHDLPath.indexOf(customerlocalLibPath);
                if (index != -1) {
                    this.opeParam.currentHDLPath.splice(index, 1);
                }
            }
            // Remove duplicate HDL files
            libFileList = this.removeDuplicates(libFileList);
            this.newLibFileList = libFileList;
            return libFileList;
        }
    }

    /**
     * delete the lib file from old lib file list
     * @returns The lib file to delete
     */
    get_del_LibFileList() {
        let delLibFileList = [];
        for (let i = 0; i < this.oldLibFileList.length; i++) {
            const oldLibFileElement = this.oldLibFileList[i];
            if (!this.newLibFileList.includes(oldLibFileElement)) {
                delLibFileList.push(oldLibFileElement);
            }
        }
        return delLibFileList;
    }

    ensureTerminalExists(name) {
        for (let index = 0; index < vscode.window.terminals.length; index++) {
            const terminalElement = vscode.window.terminals[index];
            if (terminalElement.name == name) {
                return terminalElement;
            }
        }
        return null;
    }

    /**
     * add the lib file from new lib file list
     * @returns The lib file to add
     */
    get_add_LibFileList() {
        let addLibFileList = [];
        for (let i = 0; i < this.newLibFileList.length; i++) {
            const newLibFileElement = this.newLibFileList[i];
            if (!this.oldLibFileList.includes(newLibFileElement)) {
                addLibFileList.push(newLibFileElement);
            }
        }
        return addLibFileList;
    }

    turn_local_to_lib(localLibPath, localLibFiles) {
        let libFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        getHDLFiles(localLibPath, localLibFiles);
        for (let i = 0; i < localLibFiles.length; i++) {
            const localLibElement = localLibFiles[i];
            if (localLibElement.indexOf("Customer") != -1) {
                libFiles.push(localLibElement.replace(`${localLibPath}Customer`, customerlocalLibPath));
            } else {
                libFiles.push(localLibElement.replace(localLibPath, `${this.localLibPath}/`));
            }
        }
        return libFiles;
    }

    turn_lib_to_local(localLibPath, libFiles, callback) {
        let localLibFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        for (let i = 0; i < libFiles.length; i++) {
            const libFileElement = libFiles[i];
            let dist = "";
            if (libFileElement.indexOf(customerlocalLibPath) != -1) {
                dist = libFileElement.replace(customerlocalLibPath, `${localLibPath}Customer`);
                localLibFiles.push(dist);
            } 
            else if (libFileElement.indexOf(`${this.localLibPath}/`) != -1) {
                dist = libFileElement.replace(`${this.localLibPath}/`, localLibPath);
                localLibFiles.push(dist);
            }
            let src  = libFileElement;
            callback(src, dist);
        }
    }

    addLibFiles(filePaths) {
        let content  = "";
        let terminal = this.ensureTerminalExists("StartFPGA");
        if (!fs.existsSync(this.fileScriptPath)) {
            this.script_content = '';
        }
        if (files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
            if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                for (let i = 0; i < filePaths.length; i++) {
                    const libFileElement = filePaths[i].replace("//", "/").replace(/\\/g, "\/");
                    if (terminal !== null) {
                        terminal.sendText(`add_file ${libFileElement}`);
                    } else {
                        content = `add_file ${libFileElement}\n`;
                        if (this.script_content.indexOf(content) == -1) {
                            if (this.script_content.indexOf(`remove_files ${libFileElement}\n`) == -1) {
                                this.script_content = this.script_content + content;
                            } else {
                                this.script_content.replace(`remove_files ${libFileElement}\n`, '')
                            }
                        }
                    }
                }
            }				
        }
        if (this.script_content !== "") {
            fs.writeFileSync(this.fileScriptPath, this.script_content, "utf8");
        }
    }

    delLibFiles(filePaths) {
        let content  = "";
        let terminal = this.ensureTerminalExists("StartFPGA");
        if (!fs.existsSync(this.fileScriptPath)) {
            this.script_content = '';
        }
        if (files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
            if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                for (let i = 0; i < filePaths.length; i++) {
                    const libFileElement = filePaths[i].replace("//", "/").replace(/\\/g, "\/");
                    if (terminal != null) {
                        terminal.sendText(`remove_files ${libFileElement}`);
                    } else {
                        content = `remove_files ${libFileElement}\n`;
                        if (this.script_content.indexOf(content) == -1) {
                            if (this.script_content.indexOf(`add_file ${libFileElement}\n`) == -1) {
                                this.script_content = this.script_content + content;
                            } else {
                                this.script_content.replace(`add_file ${libFileElement}\n`, '')
                            }
                        }
                    }
                }
            }				
        }
        if (this.script_content != "") {
            fs.writeFileSync(this.fileScriptPath, this.script_content, "utf8");
        }
    }

    processLibFiles() {
        let localLibPath   = "";
        let delLibFileList = [];
        let addLibFileList = [];
        if (files.isHasAttr(this.opeParam.prjInfo, "SOC_MODE.soc")) {
            if (this.opeParam.prjInfo.SOC_MODE.soc !== "none") {
                localLibPath = this.opeParam.workspacePath + "/user/Hardware/src/lib/";
            } else {
                localLibPath = this.opeParam.workspacePath + "/user/src/lib/";
            }
        }
        if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "real")) {
            this.oldLibFileList = [];
            this.turn_local_to_lib(localLibPath, this.oldLibFileList);
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.turn_lib_to_local(localLibPath, delLibFileList, (src, dist) => {
                if (fs.existsSync(dist)) {
                    fs.unlinkSync(dist);
                }
            })
            delLibFileList = [];
            this.turn_lib_to_local(localLibPath, addLibFileList, (src, dist) => {
                files.copyFile(src, dist);
            })
            addLibFileList = [];
        }
        else if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "virtual")) {
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.watcher.add(addLibFileList);
            this.watcher.unwatch(delLibFileList);
            this.addLibFiles(addLibFileList);
            this.delLibFiles(delLibFileList);
            if (fs.existsSync(localLibPath)) {
                if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                    vscode.window.showWarningMessage("src/lib will be deleted.", 'Yes', 'No').then(function (select) {
                        if (select == "Yes") {
                            dirs.deleteDir(localLibPath);
                        }
                        return;
                    });
                } else {
                    dirs.deleteDir(localLibPath);
                }
            }
        }
        this.oldLibFileList = this.newLibFileList;
        return {
            "add" : addLibFileList,
            "del" : delLibFileList
        }
    }
}
exports.processHDLFile = processHDLFile;
function getOpeParam(currentDirName, opeParam) {
    // 获取当前平台运行的系统
    opeParam.os = process.platform;
    // 获取当前根路径
    opeParam.rootPath = currentDirName.replace(/\\/g, "\/");
    // 获取当前工作区路径
    if (vscode.workspace.workspaceFolders !== undefined &&
        vscode.workspace.workspaceFolders.length !== 0) {
        opeParam.workspacePath = vscode.workspace.workspaceFolders[0].uri.fsPath;
    } else {
        opeParam.workspacePath = '';
        return null;
    }
    opeParam.workspacePath = opeParam.workspacePath.replace(/\\/g, "\/");
    console.log(opeParam.workspacePath);
    // 初始化工程参数与信息
    getPropertyInfo(opeParam);
    return opeParam;
}
exports.getOpeParam = getOpeParam;
function getPropertyInfo(opeParam) {
    opeParam.prjInfo = null;
    opeParam.prjInitParam = `${opeParam.rootPath}/../prjInitParam.json`;
    opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;
    if (!fs.existsSync(opeParam.propertyPath)) {
        if (!fs.existsSync(`${opeParam.workspacePath}/property.json`)) {
            opeParam.prjInfo = null;
            opeParam.propertyPath = "";
            opeParam.currentHDLPath = [`${opeParam.workspacePath}`];
        } else {
            opeParam.propertyPath = `${opeParam.workspacePath}/property.json`;
        }
    }
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (files.isHasAttr(opeParam.prjInfo, "SOC_MODE.soc")) {
            if (opeParam.prjInfo.SOC_MODE.soc != "none") {
                opeParam.tbFilePath = `${opeParam.workspacePath}/user/Hardware/sim`;
                opeParam.currentHDLPath = [
                    `${opeParam.workspacePath}/user/Hardware/src`,
                    `${opeParam.workspacePath}/user/Hardware/sim`,
                ];
            } else {
                opeParam.tbFilePath = `${opeParam.workspacePath}/user/sim`;
                opeParam.currentHDLPath = [
                    `${opeParam.workspacePath}/user/src`,
                    `${opeParam.workspacePath}/user/sim`,
                ];
            }
            opeParam.tbFilePath = opeParam.tbFilePath + "/testbench.v";
            if (!fs.existsSync(opeParam.tbFilePath)) {
                opeParam.tbFilePath = fspath.dirname(opeParam.tbFilePath) + "/testbench.vhd";
                if (!fs.existsSync(opeParam.tbFilePath)) {
                    opeParam.tbFilePath = fspath.dirname(opeParam.tbFilePath);
                }
            }
        }
        if (files.isHasAttr(opeParam.prjInfo, "HardwareSrc")) {
            opeParam.currentHDLPath = opeParam.prjInfo.HardwareSrc;
        }
    }
}
exports.getPropertyInfo = getPropertyInfo;
function generatePropertyFile(opeParam) {
    if (opeParam.propertyPath == "") {
        opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;
        vscode.window.showQuickPick(['.vscode', 'root'], { placeHolder: "Where you want to generate?" }).then(function (select) {
            // "Where you want to generate?"
            if (select == ".vscode") {
                opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;
            } else if (select == "root") {
                opeParam.propertyPath = `${opeParam.workspacePath}/property.json`;
            }
            files.pushJsonInfo(opeParam.propertyPath, files.pullJsonInfo(opeParam.prjInitParam));
        });
    } else {
        vscode.window.showWarningMessage("property file already exists !!!");
    }
}
exports.generatePropertyFile = generatePropertyFile;
function getHDLFiles(path, HDLFileList) {
    let HDLFileExtnames = [
        // verilog
        ".v", ".V", ".vh", ".vl", 
        // systemverilog
        ".sv", ".SV", 
        // vhdl
        ".vhd", ".vhdl", ".vho", ".vht"];
    files.pickAllFile(path, HDLFileExtnames, HDLFileList);
}

function getPrjFiles(opeParam, HDLFileList) {
    for (let index = 0; index < opeParam.currentHDLPath.length; index++) {
        const HDLFileElementPath = opeParam.currentHDLPath[index].replace("${workspce}", opeParam.workspacePath);
        getHDLFiles(HDLFileElementPath, HDLFileList);
    }
    if (opeParam.prjInfo !== null) {
        if (files.isHasAttr(opeParam.prjInfo, "FPGA_VERSION")) {
            // 获取xilinx下bd数据
            if (opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                let bd_path = `${opeParam.currentHDLPath}/bd`;
                if (fs.existsSync(bd_path)) {
                    let bd_list = fs.readdirSync(bd_path);
                    for (let i = 0; i < bd_list.length; i++) {
                        const element = bd_list[i];
                        getHDLFiles(`${bd_path}/${element}/hdl`, HDLFileList);
                        getHDLFiles(`${bd_path}/${element}/synth`, HDLFileList);
                        let ip_path = `${bd_path}/${element}/ip`;
                        if (fs.existsSync(ip_path)) {
                            let ip_list = fs.readdirSync(ip_path);
                            for (let i = 0; i < ip_list.length; i++) {
                                const element = ip_list[i];
                                getHDLFiles(`${ip_path}/${element}/synth`, HDLFileList);
                            }
                        }
                    }
                }
            }
        }
    }
}
exports.getPrjFiles = getPrjFiles;
function refreshPrjFolder(opeParam) {
    if (opeParam.prjInfo !== null) {
        dirs.mkdir(`${opeParam.workspacePath}/prj/xilinx`);
        dirs.mkdir(`${opeParam.workspacePath}/prj/intel`);
        dirs.mkdir(`${opeParam.workspacePath}/prj/simulation`);
        if (files.isHasAttr(opeParam.prjInfo, "SOC_MODE.soc")) {
            if (opeParam.prjInfo.SOC_MODE.soc == "none") {
                if (fs.existsSync(`${opeParam.workspacePath}/user/Software`)) {
                    if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                        vscode.window.showWarningMessage("Software will be deleted.", 'Yes', 'No').then(function (select) {
                            if (select == "Yes") {
                                dirs.deleteDir(`${opeParam.workspacePath}/user/Software`);
                            }
                        });
                    } else {
                        dirs.deleteDir(`${opeParam.workspacePath}/user/Software`);
                    }
                }
                if (fs.existsSync(`${opeParam.workspacePath}/user/Hardware`)) {
                    let fileList = fs.readdirSync(`${opeParam.workspacePath}/user/Hardware`);
                    for (let i = 0; i < fileList.length; i++) {
                        const element = fileList[i];
                        dirs.movedir(`${opeParam.workspacePath}/user/Hardware/${element}`, `${opeParam.workspacePath}/user`);
                    }
                    dirs.deleteDir(`${opeParam.workspacePath}/user/Hardware`);
                } else {
                    dirs.mkdir(`${opeParam.workspacePath}/user/src`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/sim`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/data`);
                }
            } else {
                if (fs.existsSync(`${opeParam.workspacePath}/user`)) {
                    let fileList = fs.readdirSync(`${opeParam.workspacePath}/user`);
                    if (!fs.existsSync(`${opeParam.workspacePath}/user/Hardware`)) {
                        dirs.mkdir(`${opeParam.workspacePath}/user/Hardware`);
                        for (let i = 0; i < fileList.length; i++) {
                            const element = fileList[i];
                            dirs.movedir(`${opeParam.workspacePath}/user/${element}`, `${opeParam.workspacePath}/user/Hardware`);
                        }
                    }
                } else {
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/src`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/sim`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/data`);
                }
                dirs.mkdir(`${opeParam.workspacePath}/user/Software/data`);
                dirs.mkdir(`${opeParam.workspacePath}/user/Software/src`);
            }
        }
    }
}
exports.refreshPrjFolder = refreshPrjFolder;
function refreshPrjInfo(opeParam) {
    if (opeParam.prjInfo !== null) {
        let xip_repo_path = vscode.workspace.getConfiguration().get('PRJ.xilinx.IP.repo.path');
        let CONFIG_content = "xip_repo_path\n";
        CONFIG_content += xip_repo_path + '\n';
        CONFIG_content += "FPGA_VERSION\n";
        CONFIG_content += opeParam.prjInfo.FPGA_VERSION + '\n';
        CONFIG_content += "PRJ_NAME.FPGA\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.FPGA + '\n';
        CONFIG_content += "PRJ_NAME.SOC\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.SOC + '\n';
        CONFIG_content += "SOC_MODE.soc\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.soc + '\n';
        CONFIG_content += "SOC_MODE.bd_file\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.bd_file + '\n';
        CONFIG_content += "SOC_MODE.os\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.os + '\n';
        CONFIG_content += "SOC_MODE.app\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.app + '\n';
        CONFIG_content += "enableShowlog\n";
        CONFIG_content += opeParam.prjInfo.enableShowlog + '\n';
        CONFIG_content += "Device\n";
        CONFIG_content += opeParam.prjInfo.Device + '\n';
        fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/CONFIG`, CONFIG_content);
        return opeParam.prjInfo;
    } else {
        return null;
    }
}
exports.refreshPrjInfo = refreshPrjInfo;
function addDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showInputBox({
        password: false,
        ignoreFocusOut: true,
        placeHolder: 'Please input the name of device',
    }).then((Device) => {
        if (propertyParam.properties.Device.enum.indexOf(Device) == -1) {
            propertyParam.properties.Device.enum.push(Device);
            files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
            vscode.window.showInformationMessage(`Add the ${Device} successfully!!!`)
        }
        else {
            vscode.window.showWarningMessage("The device already exists")
        }
    });
}
exports.addDevice = addDevice;
function delDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(propertyParam.properties.Device.enum).then(Device => {
        if (!Device) {
            return;
        }
        for (var index = 0; index < propertyParam.properties.Device.enum.length; index++) {
            if (Device == propertyParam.properties.Device.enum[index]) {
                propertyParam.properties.Device.enum.splice(index, 1);
            }
        }
        files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
        vscode.window.showInformationMessage(`Delete the ${Device} successfully!!!`)
    });
}
function overwriteInitProperty(opeParam) {
    let initPropertyPath = `${opeParam.rootPath}/../prjInitParam.json`
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(initPropertyPath), options);
}
exports.overwriteInitProperty = overwriteInitProperty;

