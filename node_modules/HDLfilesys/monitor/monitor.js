"use strict";
const vscode = require("vscode");
const fs = require("fs");
const fspath = require("path");
const chokidar = require("chokidar");
//const dir = require("../operation/dirs");
const prjs = require("HDLfilesys/operation/prjs");
//const files = require("../operation/files");

/**
 * 全局监视器
 * @param {*} path           全局监测路径
 * @param {*} opeParam       工程执行参数
 * @param {*} indexer        工程检索类
 * @param {*} outputChannel  输出log的vscode类
 * @param {*} callback       回调函数，目前用于触发tree view的更新
 * @returns 
 */
export function monitor(path, opeParam, indexer, outputChannel, callback) {
    const watcher = chokidar.watch(`${path}/**/*{log,json,v,V,sv,SV,vh,vl,vhd,vhdl,vho,vht}`, {
        persistent: true,
        usePolling: false,
        ignoreInitial: true,
        // awaitWriteFinish: {   // ms
        //     stabilityThreshold: 2000,
        //     pollInterval: 100
        // }
    });
    let processHDL = new prjs.processHDLFile(opeParam, watcher);
    if (opeParam.propertyPath != "") {
        processPropertyFile(opeParam, indexer, processHDL);
    }
    // 添加监听事件
    watcher.on('add', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${path} has been added`);
        onCreate(path, indexer, processHDL, callback, opeParam);
    });
    watcher.on('change', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${(path)} has been changed`);
        onChange(path, indexer, processHDL, callback, opeParam, outputChannel);
    });
    watcher.on('unlink', (path) => {
        path = path.replace("//","/").replace(/\\/g,"\/");
        // console.log(`File ${path} has been removed`);
        onDelete(path, indexer, processHDL, callback, opeParam);
    });

    return watcher;
    // 监听新的文件.
    // watcher.add(['new-file-2', 'new-file-3', '**/other-file*']);
    // 禁止监听指定的文件
    // watcher.unwatch('new-file*');
    // 其他可能用到的事件
    // watcher
    // .on('addDir', path => log(`Directory ${path} has been added`))
    // .on('unlinkDir', path => log(`Directory ${path} has been removed`))
    // .on('error', error => log(`Watcher error: ${error}`))
    // .on('ready', () => log('Initial scan complete. Ready for changes'))
    // .on('raw', (event, path, details) => {
    // log('Raw event info:', event, path, details);
    // });
}


async function onCreate(path, indexer, processHDL, callback, opeParam) {
    try {
        if (path.indexOf("property.json") != -1) {
            await processPropertyFile(opeParam, indexer, processHDL);
            callback();
        } else {
            let extname = fspath.extname(path).toLowerCase();
            if (extname != '.log') {
                if (existsCurrentHDLPath(opeParam, path)) {
                    await indexer.processFile(vscode.Uri.file(path), indexer.HDLparam);
                    indexer.refreshInstModulePath(indexer.HDLparam);
                    processHDL.addLibFiles([path]);
                    callback();
                }
            }
        }
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

async function onChange(path, indexer, processHDL, callback, opeParam, outputChannel) {
    try {
        if (path.indexOf("property.json") != -1) {
            await processPropertyFile(opeParam, indexer, processHDL);
            callback();
        } else {
            let extname = fspath.extname(path).toLowerCase();
            if (extname != '.log') {
                if (existsCurrentHDLPath(opeParam, path)) {
                    indexer.removeCurrentFileParam(path);
                    indexer.symbols.delete(path);
                    await indexer.processFile(vscode.Uri.file(path), indexer.HDLparam);
                    indexer.refreshInstModulePath(indexer.HDLparam);
                    callback();
                }
            } else {
                xExecShowLog(path, outputChannel);
            }
        }
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

async function onDelete(path, indexer, processHDL, callback, opeParam) {
    try {
        if (path.indexOf("property.json") != -1) {
            opeParam.propertyPath = "";
        } else {
            let extname = fspath.extname(path).toLowerCase();
            if (extname != '.log') {
                if (existsCurrentHDLPath(opeParam, path)) {
                    indexer.removeCurrentFileParam(path);
                    indexer.symbols.delete(path);
                    indexer.refreshInstModulePath(indexer.HDLparam);
                    processHDL.delLibFiles([path]);
                    if (opeParam.tbFilePath == path) {
                        opeParam.tbFilePath = fspath.dirname(opeParam.tbFilePath);
                    }
                    callback();
                }
            }
        }
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}

export async function processPropertyFile(opeParam, indexer, processHDL) {
    console.time('libtimer');
    prjs.getPropertyInfo(opeParam);   // 刷新工程信息
    prjs.refreshPrjFolder(opeParam);  // 更新工程结构
    processHDL.getLibFiles();         // 获取lib参数
    let libFiles = processHDL.processLibFiles(); // 处理lib参数
    // 从HDLparam和HDLsymbol中删除用不到的lib文件
    for (let i = 0; i < libFiles.del.length; i++) {
        const elementPath = libFiles.del[i];
        indexer.removeCurrentFileParam(elementPath);
        indexer.symbols.delete(elementPath);
    }
    // 向HDLparam和HDLsymbol中添加新lib文件
    await Promise.all(libFiles.add.map((elementPath) => {
        return indexer.processFile(vscode.Uri.file(elementPath), indexer.HDLparam);
    }));
    // 刷新路径
    if (libFiles.del.length || libFiles.add.length) {
        indexer.refreshInstModulePath(indexer.HDLparam);
    }
    console.log(indexer.HDLparam);
    console.log(indexer.symbols);
    console.timeEnd('libtimer');
}

function xExecShowLog(path, outputChannel) {
    let logPathList = ["runme.log", "xvlog.log", "elaborate.log"];
    let fileName = fspath.basename(path);
    if (logPathList.indexOf(fileName) != -1) {
        let log = "";
        let islinefinish = true;
        let content = fs.readFileSync(path, "utf-8");
        let lines = content.split('\n');
        if (lines[lines.length - 2].indexOf("INFO: [Common 17-206] Exiting Vivado") != -1) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.indexOf("INFO:") != -1 || line.indexOf("WARNING:") != -1) {
                    islinefinish = true;
                } else if (line.indexOf("ERROR:") != -1) {
                    islinefinish = false;
                    log = log + line.replace("ERROR:", "[ERROR] :") + "\n";
                } else if (line.indexOf("CRITICAL WARNING:") != -1) {
                    islinefinish = false;
                    log = log + line.replace("CRITICAL WARNING:", "[CRITICAL WARNING] :") + "\n";
                }
                if (!islinefinish) {
                    log = log + line + "\n";
                }
            }
            if (log != "") {
                outputChannel.show(true);
                outputChannel.appendLine(log);
            }
        }
    }
}

function existsCurrentHDLPath(opeParam, path) {
    let isExist = false;
    let len = opeParam.currentHDLPath.length;
    for (let index = 0; index < len; index++) {
        const elementPath = opeParam.currentHDLPath[index];
        if (path.indexOf(elementPath) != -1) {
            isExist = true;
            break;
        }
    }
    return isExist;
}